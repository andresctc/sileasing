BROKER SCHEMA mqsi
--  Generated by com.ibm.etools.mft.pattern.mbi.mrrc.synchmq Version 1.0
--  $MQSI patternName=com.ibm.etools.mft.pattern.mbi.mrrc.synchmq MQSI$
--  $MQSI patternVersion=1.0 MQSI$
 
DECLARE ErrorLoggingOn EXTERNAL BOOLEAN TRUE;
CREATE COMPUTE MODULE Create_Error_Reply
	DECLARE ErrorCodOut INTEGER;
	DECLARE ErrorCodMsg CHARACTER;
	
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
	
	
-- Copy MQMD which contains reply address
	SET OutputRoot.MQMD = InputRoot.MQMD;
-- Set CorrelId to message ID so requester can retrieve by correlId
	--SET OutputRoot.MQMD.CorrelId = InputRoot.MQMD.MsgId;
-- Set up Error response

	SET OutputRoot.MQMD.Expiry = 1200;
	
	Call ExceptionDataResponseMsg();
	
	CREATE NEXTSIBLING OF OutputRoot.MQMD DOMAIN('XMLNSC') NAME 'XMLNSC';
	SET OutputRoot.XMLNSC.responseTransaccion.cod_respuesta = '8';
	SET OutputRoot.XMLNSC.responseTransaccion.fecha_hora = CAST(CURRENT_TIMESTAMP AS TIMESTAMP);
	SET OutputRoot.XMLNSC.responseTransaccion.cod_error = ErrorCodOut;	
	SET OutputRoot.XMLNSC.responseTransaccion.mensaje_error = ErrorCodMsg;
	SET OutputRoot.XMLNSC.responseTransaccion.cod_warning = '';
	SET OutputRoot.XMLNSC.responseTransaccion.mensaje_warning = '';
	SET OutputRoot.XMLNSC.responseTransaccion.control_proceso = '8';
	SET OutputRoot.XMLNSC.responseTransaccion.tramaRespuesta = '';
	RETURN TRUE;
	END;
	
	CREATE PROCEDURE ExceptionDataResponseMsg() BEGIN
		
		   -- Add some exception data for error and fault
		DECLARE Error INTEGER;
		DECLARE Text CHARACTER;
		DECLARE ErrorUser CHARACTER;
		DECLARE Label CHARACTER;
		DECLARE I INTEGER 1;
		DECLARE K INTEGER;
		DECLARE Inserts Character;
		DECLARE start REFERENCE TO InputExceptionList.*[1];
		
		SET ErrorUser = '';
		
		WHILE start.Number IS NOT NULL DO 
			SET Label = start.Label;
			SET Error = start.Number;
			IF Error = 3001 THEN
				SET Text = start.Insert.Text;
			ELSE
				SET Text = start.Text;
			END IF;
			-- Don't include the "Caught exception and rethrowing message"
			IF Error <> 2230 THEN
				-- Process inserts
				
				DECLARE INS Integer;
				SET Inserts = '';
				-- Are there any inserts for this exception
				IF EXISTS (start.Insert[]) THEN
					-- If YES add them to inserts string
					DECLARE tempTex CHARACTER;
										
					
				 	SET Inserts = Inserts || COALESCE(start.Insert[1].Text,'NULL') || ' / ';
				 	SET K = 1;
				 	INSERTS: LOOP
						IF CARDINALITY(start.Insert[])> K 
						THEN
							SET tempTex = COALESCE(start.Insert[K+1].Text,'NULL'); 														
							SET Inserts = Inserts || tempTex || ' / ';
							
							IF CONTAINS(tempTex, '1525-ErrorUsuario') THEN
								SET ErrorUser =  REPLACE(tempTex, '1525-ErrorUsuario', '');
							END IF;
						-- No more inserts to process
						ELSE LEAVE INSERTS;
						END IF;
					SET K = K+1;
					END LOOP INSERTS;
				END IF;								
				
				--SET ERef.Exception[I].Label = Label;
				--SET ERef.Exception[I].Error = Error;
				--SET ERef.Exception[I].Text = Text;
				--Set ERef.Exception[I].Inserts = COALESCE(Inserts, '');
				
				SET I = I+1; 
			END IF;
			-- Move start to the last child of the field to which it currently points
			
				
			MOVE start LASTCHILD;
		END WHILE;
		
		IF ErrorUser='' THEN
			SET ErrorCodOut = Error;
			SET ErrorCodMsg = Inserts;
		ELSE
			SET ErrorCodOut = 1525;
			SET ErrorCodMsg = ErrorUser;
		END IF;
		
		
	--	SET ERef.cod_warning = 'N/A';
	--	SET ERef.mensaje_warning = 'N/A';			
	--	SET ERef.tramaRespuesta = 'N/A';
				
	END;	
END MODULE;

CREATE COMPUTE MODULE Build_Error_Message
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
	SET OutputRoot.MQMD = InputRoot.MQMD;
	SET OutputRoot.Properties = NULL;
	Call AddExceptionData();
    END;
	
	CREATE PROCEDURE AddExceptionData() BEGIN
	CREATE NEXTSIBLING OF OutputRoot.MQMD DOMAIN('XMLNSC') NAME 'XMLNSC';
	SET OutputRoot.XMLNSC.Error.BrokerName  = SQL.BrokerName;
	DECLARE ERef REFERENCE TO OutputRoot.XMLNSC.Error;
	SET ERef.MessageFlowLabel = SQL.MessageFlowLabel; 
    SET ERef.DTSTAMP =   CURRENT_TIMESTAMP;  
	SET ERef.StatusCode = -1;
	
    IF  Environment.Variables.RRMode = 'Response' THEN
    	SET ERef.MsgIdLog = InputRoot.MQMD.CorrelId;
    ELSE
    	SET ERef.MsgIdLog = InputRoot.MQMD.MsgId;
    END IF;
    
    -- Add some exception data for error and fault
		DECLARE Error INTEGER;
		DECLARE Text CHARACTER;
		DECLARE Label CHARACTER;
		DECLARE I INTEGER 1;
		DECLARE K INTEGER;
		DECLARE start REFERENCE TO InputExceptionList.*[1];

		WHILE start.Number IS NOT NULL DO 
			SET Label = start.Label;
			SET Error = start.Number;
			IF Error = 3001 THEN
				SET Text = start.Insert.Text;
			ELSE
				SET Text = start.Text;
			END IF;
			-- Don't include the "Caught exception and rethrowing message"
			IF Error <> 2230 THEN
				-- Process inserts
				DECLARE Inserts Character;
				DECLARE INS Integer;
				SET Inserts = '';
				-- Are there any inserts for this exception
				IF EXISTS (start.Insert[]) THEN
					-- If YES add them to inserts string
				 	SET Inserts = Inserts || COALESCE(start.Insert[1].Text,'NULL')|| ' / ';
				 	SET K = 1;
				 	INSERTS: LOOP
						IF CARDINALITY(start.Insert[])> K 
						THEN 
							SET Inserts = Inserts || COALESCE(start.Insert[K+1].Text,'NULL')|| ' / ';
						-- No more inserts to process
						ELSE LEAVE INSERTS;
						END IF;
					SET K = K+1;
					END LOOP INSERTS;
				END IF;
				SET ERef.Exception[I].Label = Label;
				SET ERef.Exception[I].Error = Error;
				SET ERef.Exception[I].Text = Text;
				Set ERef.Exception[I].Inserts = COALESCE(Inserts, '');
				
				SET I = I+1; 
			END IF;
			-- Move start to the last child of the field to which it currently points
			MOVE start LASTCHILD;
		END WHILE;

	END;
	

END MODULE;

CREATE FILTER MODULE ErrorQ_check
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
-- Do not write a second error message if this message has already been backed out
	IF Root.MQMD.BackoutCount > 0 THEN RETURN FALSE; 		
	ELSE RETURN ErrorLoggingOn;
	END IF;
	END;
END MODULE;

CREATE FILTER MODULE Request_Check
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
-- Do not send a reply if this message has already been backed out
	IF Root.MQMD.BackoutCount > 0 THEN RETURN FALSE; END IF;
-- Only send a reply if in request mode (do not know where to go if error is in response flow)
	IF  Environment.Variables.RRMode = 'Request' 
	THEN RETURN TRUE;
	ELSE RETURN FALSE;
	END IF;
	END;
END MODULE;



CREATE COMPUTE MODULE WriteError
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
	
	CALL CopyMessageHeaders();
	
	Declare Text CHARACTER;
	
	SET Text = FIELDNAME(InputBody);
	
	IF Text='XMLNSC' THEN
		DECLARE wholeMsgBlob BLOB ASBITSTREAM(InputRoot.XMLNSC,InputRoot.Properties.Encoding,InputRoot.Properties.CodedCharSetId );						
		SET OutputRoot.BLOB.BLOB = wholeMsgBlob;			
	END IF;

		RETURN TRUE;
	END;
	
	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;
	
END MODULE;

CREATE COMPUTE MODULE Error_Log
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
	
		SET InputLocalEnvironment.Variables.log = 'true'; 
		
		SET OutputRoot = InputRoot;

		RETURN TRUE;
	END;

END MODULE;
